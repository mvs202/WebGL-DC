<!-- Based on @mrdoob's "Procedural City" http://mrdoob.com/lab/javascript/webgl/city/01/ -->
<html>
<head>
<title>Lincoln Memorial and Washington Monument</title>
<style>
body {
  background-color: #000000;
  font-family: Monospace;
  cursor: url(cursor.png), auto;
  margin: 0;
  overflow: hidden;
  }
#instructions {
  position: absolute;
  top: 15px;
  width: 100%;
  color: #BBBBFF;
  text-align: center;
  }
</style>
</head>
<body>
<script src="../../lib/three.min.js"></script>
<script src="../../lib/FirstPersonControls.js"></script>
<script>
// Mesh = Geometry + Material
var scene, camera, renderer;
var light, controls;
var lastTime;
var minLng, maxLng, minLat, maxLat;
var worldWidth = 400;
var worldHeight = 400;

function WashingtonMonument(lat, lng) {
  var obeliskGeometry = new THREE.Geometry();
  var height = 169.29;  // height in meters
  var pyramidBase = 0.9*height;
  var pyramidHalfWidth = 0.03*height;
  var bottomHalfWidth = 0.05*height;
  // Define each vertex:
  // The bottom plane:
  obeliskGeometry.vertices.push(new THREE.Vector3( bottomHalfWidth,            0,  bottomHalfWidth));
  obeliskGeometry.vertices.push(new THREE.Vector3( bottomHalfWidth,            0, -bottomHalfWidth));
  obeliskGeometry.vertices.push(new THREE.Vector3(-bottomHalfWidth,            0, -bottomHalfWidth));
  obeliskGeometry.vertices.push(new THREE.Vector3(-bottomHalfWidth,            0,  bottomHalfWidth));
  // Base of the pyramid:
  obeliskGeometry.vertices.push(new THREE.Vector3( pyramidHalfWidth, pyramidBase,  pyramidHalfWidth));
  obeliskGeometry.vertices.push(new THREE.Vector3( pyramidHalfWidth, pyramidBase, -pyramidHalfWidth));
  obeliskGeometry.vertices.push(new THREE.Vector3(-pyramidHalfWidth, pyramidBase, -pyramidHalfWidth));
  obeliskGeometry.vertices.push(new THREE.Vector3(-pyramidHalfWidth, pyramidBase,  pyramidHalfWidth));
  // The tippy-top:
  obeliskGeometry.vertices.push(new THREE.Vector3(0, height, 0));
  // Create the faces:
  // Floor:
  obeliskGeometry.faces.push(new THREE.Face3(0, 2, 1), new THREE.Face3(0, 3, 2));
  // The four main sides (each side is two triangles):
  obeliskGeometry.faces.push(new THREE.Face3(0, 1, 5), new THREE.Face3(0, 5, 4));
  obeliskGeometry.faces.push(new THREE.Face3(1, 2, 6), new THREE.Face3(1, 6, 5));
  obeliskGeometry.faces.push(new THREE.Face3(2, 3, 7), new THREE.Face3(2, 7, 6));
  obeliskGeometry.faces.push(new THREE.Face3(3, 0, 4), new THREE.Face3(3, 4, 7));
  // Four sides of the pyramid:
  obeliskGeometry.faces.push(new THREE.Face3(4, 5, 8));
  obeliskGeometry.faces.push(new THREE.Face3(6, 7, 8));
  obeliskGeometry.faces.push(new THREE.Face3(5, 6, 8));
  obeliskGeometry.faces.push(new THREE.Face3(7, 4, 8));
  obeliskGeometry.computeFaceNormals();  // required when using MeshNormalMaterial
  var c1 = new THREE.Color();
  var c2 = new THREE.Color();
  c1.setHSL(0, 0, 1.0);
  c2.setHSL(0, 0, 0.8);
  for (var i = 0; i < obeliskGeometry.faces.length; i++) {
    if (i % 4 < 2) {
      obeliskGeometry.faces[i].color.set(c1);
      }
    else {
      obeliskGeometry.faces[i].color.set(c2);
      }
    }
  obelisk = new THREE.Mesh(obeliskGeometry, new THREE.MeshLambertMaterial({vertexColors: THREE.VertexColors}));
  obelisk.position.x = latToX(lat);
  obelisk.position.z = lngToZ(lng);
  return obelisk;
  }

function latToX(lat) {
  return worldWidth*(lat - minLat)*(maxLat - minLat) - worldWidth/2;
  }

function lngToZ(lng) {
  return worldHeight*(lng - minLng)*(maxLng - minLng) - worldHeight/2;
  }

function LincolnMemorial(lat, lng) {
  var columnWidth = 61/23;  // about 2.65 meters
  var memorialWidth = columnWidth*23;  // 23 = 12 columns + 11 spaces
  var memorialDepth = columnWidth*15;  // 15 = 8 columns + 7 spaces
  var singleGeometry = new THREE.Geometry();
  cube = new THREE.CubeGeometry(memorialWidth - 11, 29, memorialDepth - 11);
  var mesh = new THREE.Mesh(cube);
  mesh.position.y = 29/2;
  mesh.updateMatrix();
  singleGeometry.merge(mesh.geometry, mesh.matrix);
  cube = new THREE.CubeGeometry(memorialWidth, 4, memorialDepth);
  var mesh = new THREE.Mesh(cube);
  mesh.position.y = 21;
  mesh.updateMatrix();
  singleGeometry.merge(mesh.geometry, mesh.matrix);
  cube = new THREE.CubeGeometry(memorialWidth,  3, memorialDepth);
  var mesh = new THREE.Mesh(cube);
  mesh.position.y = 3/2;
  mesh.updateMatrix();
  singleGeometry.merge(mesh.geometry, mesh.matrix);
  cube = new THREE.CubeGeometry(memorialWidth + 2,  2, memorialDepth + 2);
  var mesh = new THREE.Mesh(cube);
  mesh.position.y = 2/2;
  mesh.updateMatrix();
  singleGeometry.merge(mesh.geometry, mesh.matrix);
  cube = new THREE.CubeGeometry(memorialWidth + 4,  1, memorialDepth + 4);
  var mesh = new THREE.Mesh(cube);
  mesh.position.y = 1/2;
  mesh.updateMatrix();
  singleGeometry.merge(mesh.geometry, mesh.matrix);
  for (var i = 0; i < 24; i++) {
    var geometry = new THREE.CylinderGeometry(columnWidth/2 - 0.1, columnWidth/2 - 0.01, 16, 24);  // radiusTop, radiusBottom, height, segments
    var material = new THREE.MeshBasicMaterial({color: 0xffffff});
    var cylinder = new THREE.Mesh( geometry, material );
    cylinder.position.y = 11;
    cylinder.position.x = (i % 12 - 5.5)*2*61/23;
    cylinder.position.z = 20 - 1.33;
    if (i >= 12) {cylinder.position.z *= -1;}
    cylinder.updateMatrix();
    singleGeometry.merge(cylinder.geometry, cylinder.matrix);
    }
  for (var i = 0; i < 12; i++) {
    var geometry = new THREE.CylinderGeometry(1.33, 1.33, 16, 24);
    var material = new THREE.MeshLambertMaterial({color: 0xffffff});
    var cylinder = new THREE.Mesh( geometry, material );
    cylinder.position.y = 11;
    cylinder.position.x = 5.5*2*61/23;
    cylinder.position.z = (i % 6 - 2.5)*2*61/23;
    if (i >= 6) {cylinder.position.x *= -1;}
    cylinder.updateMatrix();
    singleGeometry.merge(cylinder.geometry, cylinder.matrix);
    }
  var material = new THREE.MeshLambertMaterial({color: 0xffeeff});
  return new THREE.Mesh(singleGeometry, material);
  }

function setBoundary(background, south, west, north, east, w, h) {
  minLng = west;  // left
  maxLng = east;  // right
  minLat = south;  // bottom
  maxLat = north;  // top
  swidth = w;
  sheight = h;
  }

function init() {
  setBoundary("region640x640dark.png", 38.78854, -77.27364, 39.12946, -76.83205, 640, 640);
  renderer = new THREE.WebGLRenderer({antialias: true, alpha: false});
  renderer.setClearColor(0x202040);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 1, 3000);
  camera.position.x = -100;
  camera.position.z = -100;
  camera.position.y = 20;
  controls = new THREE.FirstPersonControls(camera);
  controls.movementSpeed = 25;
  controls.lookSpeed = 0.05;
  controls.lookVertical = true;
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.0015);  // color, density
  var directionalLight = new THREE.DirectionalLight(0xffffee, 0.5);
  directionalLight.position.set(-800, 1600, 400);
  scene.add(directionalLight);
  scene.add(new THREE.HemisphereLight(0xffffff , 0x000088, 1));  // skyColorHex, groundColorHex, intensity
  scene.add(new THREE.AmbientLight(0x334444));
  //var plane = new THREE.Mesh(new THREE.PlaneGeometry(worldWidth, worldHeight), new THREE.MeshBasicMaterial({color: 0x101020}));
  //scene.add(plane);
  var curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-worldWidth/2,  0, -worldHeight/2),
    new THREE.Vector3(   0, 50,    0),
    new THREE.Vector3( worldWidth/2,  0,  worldHeight/2)
    ]);
  var geometry = new THREE.Geometry();
  geometry.vertices = curve.getPoints(50);
  var material = new THREE.LineBasicMaterial({color: 0xff0000});
  var splineObject = new THREE.Line(geometry, material);
  scene.add(splineObject);
  var curve = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-worldWidth/2,  0,  worldHeight/2),
    new THREE.Vector3(   0, 50,    0),
    new THREE.Vector3( worldWidth/2,  0, -worldHeight/2)
    ]);
  var geometry = new THREE.Geometry();
  geometry.vertices = curve.getPoints(50);
  var material = new THREE.LineBasicMaterial({color: 0xff0000});
  var splineObject = new THREE.Line(geometry, material);
  scene.add(splineObject);
  scene.add(WashingtonMonument(38.889376, -77.035246));
  scene.add(LincolnMemorial(38.889376, -77.050153));
  lastTime = window.performance ? performance.now() : Date.now();
  }

function animate() {
  requestAnimationFrame(animate);
  var time = (window.performance ? performance.now() : Date.now())/1000;
  controls.update(time - lastTime);
  renderer.render(scene, camera);
  lastTime = time;
  }

init();
animate();
</script>
<div id=instructions >click and hold to move forward</div>
</body>
</html>
